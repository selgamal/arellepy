import os, sys, io
from arelle import PythonUtil, ModelDocument
from arelle import XbrlConst
from arelle.ValidateFilingText import referencedFiles
# import plugin.EdgarRenderer as ed
# from plugin.EdgarRenderer import edgarRendererFilingStart, edgarRendererXbrlRun, edgarRendererFilingEnd, Filing, RefManager
sys.path.append('/home/sherif/projects/vscode_projects/')
import EdgarRenderer_git as ed 
from EdgarRenderer_git import edgarRendererFilingStart, edgarRendererXbrlRun, edgarRendererFilingEnd, Filing, RefManager





def getEdgarFilingSummary(cntlr, modelXbrl, isNonEFMorGFMinline=False, showTableMenu=True):
    '''Get summary generated by EdgarRenderer plugin, does not generate reports, just get the summaries'''
    parameters = modelXbrl.modelManager.formulaOptions.parameterValues
    _combinedReports = showTableMenu

    options = PythonUtil.attrdict(  # simulate options that CntlrCmdLine provides
        configFile=os.path.join(os.path.dirname(
            ed.__file__), 'conf', 'config_for_instance.xml'),
        renderingService='Instance',
        # for Rall temporarily override report format to force only xml file output
        reportFormat="None" if isNonEFMorGFMinline else "Html",
        htmlReportFormat=None,
        zipOutputFile=None,
        sourceList=None,  # after initialization this is an iterable string, not a None
        internetConnectivity=None,
        totalClean=True,  # force clean output folder
        noEquity=None,
        auxMetadata=None,
        copyInlineFilesToOutput=True,  # needed for ixviewer
        copyXbrlFilesToOutput=None,
        zipXbrlFilesToOutput=None,
        includeLogsInSummary=(True if "includeLogsInSummary" in parameters else
                              False if "noLogsInSummary" in parameters else
                              True),  # default for GUI logger now validates with log buffer
        includeLogsInSummaryDissem=True if "includeLogsInSummaryDissem" in parameters else False,
        # both options can work with GUI, unsure about future browser XSLT support
        processXsltInBrowser=False,
        saveTargetInstance=None,
        saveTargetFiling=None,
        deleteProcessedFilings=None,
        debugMode=None,
        validate=None,
        utrValidate=None,
        validateEFM=None,
        abortOnMajorError=False,  # inherited
        processingFolder=None,
        processInZip=None,
        # default to reports subdirectory of source input
        reportsFolder= None,
        noReportOutput= True, # do not generate reports
        reportInZip=None,
        resourcesFolder=None,
        reportXslt=(parameters["reportXslt"][1] if "reportXslt" in parameters else
                      ('InstanceReport.xslt', 'InstanceReportTable.xslt')[_combinedReports]),
        reportXsltDissem=parameters["reportXsltDissem"][1] if "reportXsltDissem" in parameters else None,
        summaryXslt=(parameters["summaryXslt"][1] if "summaryXslt" in parameters else
                     ('Summarize.xslt', '')[_combinedReports]),  # no FilingSummary.htm for Rall.htm production
        summaryXsltDissem=parameters["summaryXslt"][1] if "summaryXslt" in parameters else None,
        renderingLogsXslt=('RenderingLogs.xslt', None)[_combinedReports],
        excelXslt=('InstanceReport_XmlWorkbook.xslt', None)[_combinedReports],
        logMessageTextFile=None,
        logFile=None  # from cntlrCmdLine but need to simulate for GUI operation
    )


    reportedFiles = set()
    if modelXbrl.modelDocument.type == ModelDocument.Type.INLINEXBRLDOCUMENTSET:
        for ixDoc in modelXbrl.modelDocument.referencesDocument.keys():
            if ixDoc.type == ModelDocument.Type.INLINEXBRL:
                reportedFiles.add(ixDoc.basename)
    else:
        reportedFiles.add(modelXbrl.modelDocument.basename)
    reportedFiles |= referencedFiles(modelXbrl)


    instDocs = ([modelXbrl.modelDocument] if modelXbrl.modelDocument.type != ModelDocument.Type.INLINEXBRLDOCUMENTSET
                else [])+ [ixDoc
                            for ixDoc in sorted(modelXbrl.modelDocument.referencesDocument.keys(), key=lambda d: d.objectIndex)
                            if ixDoc.type == ModelDocument.Type.INLINEXBRL]

    report = PythonUtil.attrdict( # simulate report
        isInline = modelXbrl.modelDocument.type in (ModelDocument.Type.INLINEXBRL, ModelDocument.Type.INLINEXBRLDOCUMENTSET),
        reportedFiles = reportedFiles,
        renderedFiles = set(),
        entryPoint = {"file": modelXbrl.modelDocument.uri},
        url = modelXbrl.modelDocument.uri,
        filepaths = [doc.filepath for doc in instDocs],
        basenames = [doc.basename for doc in instDocs],
        documentType = None
    )

    for concept in modelXbrl.nameConcepts["DocumentType"]:
        for f in modelXbrl.factsByQname[concept.qname]:
            cntx = f.context
            if cntx is not None and not cntx.hasSegment and f.xValue:
                report.documentType = f.xValue # find document type for mustard menu
                break

    def guiWriteFile(filepath, data):
        outdir = os.path.dirname(filepath)
        if not os.path.exists(outdir): # may be a subdirectory of out dir
            os.makedirs(outdir)
        with io.open(filepath, "wb" if isinstance(data, bytes) else "wt") as fh:
            fh.write(data)
    def guiReadFile(filepath, binary):
        return modelXbrl.fileSource.file(filepath, binary)


    filing = PythonUtil.attrdict( # simulate filing
        filesource = modelXbrl.fileSource,
        reportZip = None,
        entrypointfiles = [{"file":modelXbrl.modelDocument.uri}],
        renderedFiles = set(),
        reports = [report],
        hasInlineReport = report.isInline,
        arelleUnitTests = {},
        writeFile=guiWriteFile,
        readFile=guiReadFile
    )

    edgarRendererFilingStart(cntlr, options, {}, filing)
    edgarRendererXbrlRun(cntlr, options, modelXbrl, filing, report)
    edgarRendererFilingEnd(cntlr, options, modelXbrl.fileSource, filing)


    return [x for x in filing['edgarRenderer'].instanceSummaryList]

def getFilingStats(modelXbrl):
    '''For testing, gets basic information about a filing, number for custom items, dims...'''
    efmStandardAuthorities = ["sec.gov", "fasb.org", "xbrl.org", "xbrl.us", "w3.org", "ifrs.org"]
    isEfmStandardNamespaceRegex = re.compile('^http(s)?://.*(' + "|".join(efmStandardAuthorities) + ")/.*")
    contexts = set(modelXbrl.contexts.values())
    customNS = [x for x in modelXbrl.namespaceDocs if not isEfmStandardNamespaceRegex.match(x)][0]
    arelle_schema_objs = [x for x in modelXbrl.namespaceDocs[customNS][0].idObjects.values()]
    arelle_schema_elts = [x for x in arelle_schema_objs if x.localName == 'element']

    primaryInUse = {i for y in map(lambda x: [f.concept for f in x[1]], modelXbrl.factsByQname.items()) for i in y}
    if None in primaryInUse: 
        primaryInUse.remove(None)
    dimsInUse, membersInUse = zip(*{(s.dimension, s.member) for c in contexts for s in c.segDimValues.values() if s.dimension is not None})
    dimsInUse = set(dimsInUse) 
    if None in dimsInUse: 
        dimsInUse.remove(None)
    membersInUse = set(membersInUse)
    if None in membersInUse: 
        membersInUse.remove(None)

    # hypercubes and domains
    hypercubes = set()
    domains = set()
    lineItemsInUse = set()
    otherAbstractsEltInUse = set()
    unIdentifiedInUSe = set()

    for baseSetKey, baseSetModelLinks  in modelXbrl.baseSets.items():
        arcrole, ELR, linkqname, arcqname = baseSetKey
        if ELR and linkqname and arcqname and not arcrole.startswith("XBRL-"):
            if arcrole in (XbrlConst.all, XbrlConst.notAll):
                hasHypercubeRelationships = modelXbrl.relationshipSet(arcrole, ELR).fromModelObjects()
                for hasHcRels in hasHypercubeRelationships.values():
                    for hasHcRel in hasHcRels:
                        lineItem = hasHcRel.fromModelObject
                        hc = hasHcRel.toModelObject
                        hypercubes.add(hc)
                        lineItemsInUse.add(lineItem)
            elif arcrole in (XbrlConst.dimensionDomain, XbrlConst.dimensionDefault):
                fromRelationships = modelXbrl.relationshipSet(arcrole,ELR).fromModelObjects()
                for relFrom, rels in fromRelationships.items():
                    for rel in rels:
                        relTo = rel.toModelObject
                        domains.add(relTo)

    # Instance stats
    segmentsSet = set()
    entitiesSet = set()
    for c in contexts:
        entitiesSet.add(c.entityIdentifier)
        for s in c.segDimValues.values():
            segmentsSet.add((s.dimension, s.member))

    unitsSet = modelXbrl.units

    allInUse = [primaryInUse, dimsInUse, membersInUse, domains, hypercubes, lineItemsInUse, 
                otherAbstractsEltInUse, unIdentifiedInUSe]

    customConcepts = [len(y) for y in map(lambda x: [c for c in x if not isEfmStandardNamespaceRegex.match(c.qname.namespaceURI)], allInUse)]
    missing_ = {c for c in arelle_schema_elts if c not in [y for x in allInUse for y in x if not isEfmStandardNamespaceRegex.match(c.qname.namespaceURI)]}
    
    # probably missing titles, look in presentation
    nonDimAbstracts = set()
    if len(missing_) > 0:
        pre_from = modelXbrl.relationshipSet(XbrlConst.parentChild).fromModelObjects()
        for parentConcept in pre_from:
            if parentConcept in missing_ and len(pre_from[parentConcept]):
                otherAbstractsEltInUse.add(parentConcept)
        missing_ = missing_ - otherAbstractsEltInUse
        nonDimAbstracts = {x for x in missing_ if pre_from[x]}

    allresults = {
        'primaryInUse': primaryInUse, 'dimsInUse': dimsInUse,
        'membersInUse':membersInUse, 'domains':domains,
        'hypercubes':hypercubes, 'lineItemsInUse':lineItemsInUse,
        'otherAbstractsEltInUse':otherAbstractsEltInUse,
        'nonDimAbstracts':nonDimAbstracts, 'missing_':missing_,
        'segmentsSet':segmentsSet, 'entitiesSet':entitiesSet,
        'unitsSet':unitsSet, 'contexts':contexts, 'facts': modelXbrl.factsInInstance
    }

    return {x:len(y)  for x,y in allresults.items()}


